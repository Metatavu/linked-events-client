/**
 * Linked Events information API
 * Linked Events provides categorized data on events and places using JSON-LD format.  Events can be searched by date and location. Location can be exact address or larger area such as neighbourhood or borough  JSON-LD format is streamlined using include mechanism. API users can request that certain fields are included directly into the result, instead of being hyperlinks to objects.  Several fields are multilingual. These are implemented as object with each language variant as property. In this specification each multilingual field has (fi,sv,en) property triplet as example.
 *
 * OpenAPI spec version: v1
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.2.3
 *
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/Image', 'model/KeywordName'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('./Image'), require('./KeywordName'));
  } else {
    // Browser globals (root is window)
    if (!root.LinkedeventsClient) {
      root.LinkedeventsClient = {};
    }
    root.LinkedeventsClient.Keyword = factory(root.LinkedeventsClient.ApiClient, root.LinkedeventsClient.Image, root.LinkedeventsClient.KeywordName);
  }
}(this, function(ApiClient, Image, KeywordName) {
  'use strict';




  /**
   * The Keyword model module.
   * @module model/Keyword
   * @version 0.0.5
   */

  /**
   * Constructs a new <code>Keyword</code>.
   * Keywords are used to describe events. Linked events uses namespaced keywords in order to support having events from different sources. Namespaces are needed because keywords are defined by the organization sourcing the events and can therefore overlap in meaning. Conversely the meaning of same keyword can vary between organizations. Organization sourcing the keyword can be identified by data_source field. Data_source field will later specify standardized namespaces as well.
   * @alias module:model/Keyword
   * @class
   * @param id {String} Consists of source prefix and source specific identifier. These should be URIs uniquely identifying the keyword, and preferably also well formed http-URLs pointing to more information about the keyword.
   * @param dataSource {String} Source of the keyword, typically API provider specific identifier. Will also be used to specify standardized namespaces as they are brought into use.
   */
  var exports = function(id, dataSource) {
    var _this = this;

    _this['id'] = id;






    _this['data_source'] = dataSource;



  };

  /**
   * Constructs a <code>Keyword</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Keyword} obj Optional instance to populate.
   * @return {module:model/Keyword} The populated <code>Keyword</code> instance.
   */
  exports.constructFromObject = function(data, obj) {
    if (data) {
      obj = obj || new exports();

      if (data.hasOwnProperty('id')) {
        obj['id'] = ApiClient.convertToType(data['id'], 'String');
      }
      if (data.hasOwnProperty('name')) {
        obj['name'] = KeywordName.constructFromObject(data['name']);
      }
      if (data.hasOwnProperty('images')) {
        obj['images'] = ApiClient.convertToType(data['images'], [Image]);
      }
      if (data.hasOwnProperty('origin_id')) {
        obj['origin_id'] = ApiClient.convertToType(data['origin_id'], 'String');
      }
      if (data.hasOwnProperty('created_time')) {
        obj['created_time'] = ApiClient.convertToType(data['created_time'], 'Date');
      }
      if (data.hasOwnProperty('last_modified_time')) {
        obj['last_modified_time'] = ApiClient.convertToType(data['last_modified_time'], 'Date');
      }
      if (data.hasOwnProperty('aggregate')) {
        obj['aggregate'] = ApiClient.convertToType(data['aggregate'], 'Boolean');
      }
      if (data.hasOwnProperty('data_source')) {
        obj['data_source'] = ApiClient.convertToType(data['data_source'], 'String');
      }
      if (data.hasOwnProperty('created_by')) {
        obj['created_by'] = ApiClient.convertToType(data['created_by'], 'String');
      }
      if (data.hasOwnProperty('last_modified_by')) {
        obj['last_modified_by'] = ApiClient.convertToType(data['last_modified_by'], 'String');
      }
      if (data.hasOwnProperty('alt_labels')) {
        obj['alt_labels'] = ApiClient.convertToType(data['alt_labels'], ['String']);
      }
    }
    return obj;
  }

  /**
   * Consists of source prefix and source specific identifier. These should be URIs uniquely identifying the keyword, and preferably also well formed http-URLs pointing to more information about the keyword.
   * @member {String} id
   */
  exports.prototype['id'] = undefined;
  /**
   * @member {module:model/KeywordName} name
   */
  exports.prototype['name'] = undefined;
  /**
   * @member {Array.<module:model/Image>} images
   */
  exports.prototype['images'] = undefined;
  /**
   * Identifier for the keyword in the organization using this keyword. For standardized namespaces this will be a shared identifier.
   * @member {String} origin_id
   */
  exports.prototype['origin_id'] = undefined;
  /**
   * Creation time for the keyword entry.
   * @member {Date} created_time
   */
  exports.prototype['created_time'] = undefined;
  /**
   * Time this place was modified in the datastore behind the API (not necessarily in the originating system)
   * @member {Date} last_modified_time
   */
  exports.prototype['last_modified_time'] = undefined;
  /**
   * FIXME(verify) This keyword is an combination of several keywords at source
   * @member {Boolean} aggregate
   */
  exports.prototype['aggregate'] = undefined;
  /**
   * Source of the keyword, typically API provider specific identifier. Will also be used to specify standardized namespaces as they are brought into use.
   * @member {String} data_source
   */
  exports.prototype['data_source'] = undefined;
  /**
   * FIXME(verify) URL reference to the user that created this record (user endpoint)
   * @member {String} created_by
   */
  exports.prototype['created_by'] = undefined;
  /**
   * FIXME(verify) URL reference to the user that last modfied this record (user endpoint)
   * @member {String} last_modified_by
   */
  exports.prototype['last_modified_by'] = undefined;
  /**
   * FIXME(verify) alternative labels for this keyword, no language specified. Use case?
   * @member {Array.<String>} alt_labels
   */
  exports.prototype['alt_labels'] = undefined;



  return exports;
}));


