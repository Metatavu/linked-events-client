/*
 * Linked Events information API
 * Linked Events provides categorized data on events and places using JSON-LD format.  Events can be searched by date and location. Location can be exact address or larger area such as neighbourhood or borough  JSON-LD format is streamlined using include mechanism. API users can request that certain fields are included directly into the result, instead of being hyperlinks to objects.  Several fields are multilingual. These are implemented as object with each language variant as property. In this specification each multilingual field has (fi,sv,en) property triplet as example.
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package fi.metatavu.linkedevents.client;

import fi.metatavu.linkedevents.client.model.*;

import fi.metatavu.linkedevents.client.model.InlineResponse2002;
import fi.metatavu.linkedevents.client.model.InlineResponse2003;
import fi.metatavu.linkedevents.client.model.InlineResponse2004;
import fi.metatavu.linkedevents.client.model.Keyword;
import fi.metatavu.linkedevents.client.model.KeywordSet;
import java.time.OffsetDateTime;
import fi.metatavu.linkedevents.client.model.Place;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2017-06-02T10:07:32.014+03:00")
public class FilterApi {

  private ApiClient client;
  private String baseUrl;

  public FilterApi(String baseUrl, ApiClient client) {
    this.client = client;
    this.baseUrl = baseUrl;
  }
  
  /**
   * Returns a list of keywords used for describing events
   * keyword endpoint returns keywords connected with events. What this means is that nearly all filtering is applied to events. Response then contains those keywords that are associated with the events that have passed filters. Exceptions to this are marked. 
   * @param page request particular page in paginated results (optional)
   * @param pageSize request that server delivers page_size results in response (optional)
   * @param include Embed given reference-type fields directly into the response, otherwise they are returned as URI references. (optional)
   * @param showAllKeywords Show all keywords, including those that are not associated with any events. Otherwise such keywords are hidden. When show_all_keywords is specified, no other filter is applied, **except** \&quot;filter\&quot; (match for keywords beginning with string) (optional)
   * @param dataSource Search for keywords (**note**: NOT events) that come from the specified data source (see data source in keyword definition). (optional)
   * @param filter Search for keywords (**note**: NOT events) that begin with the given string. This applies even when show_all_keywords is specified. (optional)
   * @param text Search (case insensitive) through all multilingual text fields (name, description, short_description, info_url) of an event (every language). Multilingual fields contain the text that users are expected to care about, thus multilinguality is useful discriminator. (optional)
   * @param lastModifiedSince Search for events that have been modified since or at this time. (optional)
   * @param start Search for events beginning or ending after this time. Dates can be specified using ISO 8601 (\&quot;2016-01-12\&quot;) and additionally \&quot;today\&quot;. (optional)
   * @param end Search for events beginning or ending before this time. Dates can be specified using ISO 8601 (\&quot;2016-01-12\&quot;) and additionally \&quot;today\&quot;. (optional)
   * @param bbox Search for events that are within this bounding box. Decimal coordinates are given in order west, south, east, north. Period is used as decimal separator. (optional)
   * @param location Search for events in given locations as specified by id. Multiple ids are separated by comma (optional)
   * @param keyword Search for events with given keywords as specified by id. Multiple ids are separated by comma (optional)
   * @param recurring Search for events based on whether they are part of recurring event set. &#39;super&#39; specifies recurring, while &#39;sub&#39; is non-recurring. (optional)
   * @param minDuration Search for events that are longer than given time in seconds (optional)
   * @param maxDuration Search for events that are shorter than given time in seconds (optional)
   * @param organization Search for events that have given organization as source (optional)
   */
  public ApiResponse<InlineResponse2002> keywordList(Integer page, Integer pageSize, List<String> include, Boolean showAllKeywords, String dataSource, String filter, String text, String lastModifiedSince, OffsetDateTime start, OffsetDateTime end, List<String> bbox, List<Integer> location, String keyword, String recurring, Integer minDuration, Integer maxDuration, String organization) {
    Map<String, Object> queryParams = new HashMap<>();
    Map<String, Object> formParams = new HashMap<>();
    if (page != null)
    queryParams.put("page", page);
if (pageSize != null)
    queryParams.put("page_size", pageSize);
if (include != null)
    queryParams.put("include", include);
if (showAllKeywords != null)
    queryParams.put("show_all_keywords", showAllKeywords);
if (dataSource != null)
    queryParams.put("data_source", dataSource);
if (filter != null)
    queryParams.put("filter", filter);
if (text != null)
    queryParams.put("text", text);
if (lastModifiedSince != null)
    queryParams.put("last_modified_since", lastModifiedSince);
if (start != null)
    queryParams.put("start", start);
if (end != null)
    queryParams.put("end", end);
if (bbox != null)
    queryParams.put("bbox", bbox);
if (location != null)
    queryParams.put("location", location);
if (keyword != null)
    queryParams.put("keyword", keyword);
if (recurring != null)
    queryParams.put("recurring", recurring);
if (minDuration != null)
    queryParams.put("min_duration", minDuration);
if (maxDuration != null)
    queryParams.put("max_duration", maxDuration);
if (organization != null)
    queryParams.put("organization", organization);
    
        
    String requestPath = String.format("%s/keyword/", baseUrl);
      
    ResultType<InlineResponse2002> resultType = new ResultType<InlineResponse2002>() {};
    return client.doGETRequest(requestPath, resultType, queryParams, formParams);
  }
  /**
   * Return information for single keyword
   * 
   * @param id Same as id in keyword schema (required)
   */
  public ApiResponse<Keyword> keywordRetrieve(String id) {
    Map<String, Object> queryParams = new HashMap<>();
    Map<String, Object> formParams = new HashMap<>();
        
        
    String requestPath = String.format("%s/keyword/{id}/"
      .replaceAll("\\{" + "id" + "\\}", id), baseUrl);
      
    ResultType<Keyword> resultType = new ResultType<Keyword>() {};
    return client.doGETRequest(requestPath, resultType, queryParams, formParams);
  }
  /**
   * Return as list of keyword_sets for grouping keywords
   * Unlike other endpoints, keyword_sets do not support filtering. It is expected that the full result set will remain small enough.
   * @param page request particular page in paginated results (optional)
   * @param pageSize request that server delivers page_size results in response (optional)
   * @param include Embed given reference-type fields directly into the response, otherwise they are returned as URI references. (optional)
   */
  public ApiResponse<InlineResponse2003> keywordSetList(Integer page, Integer pageSize, List<String> include) {
    Map<String, Object> queryParams = new HashMap<>();
    Map<String, Object> formParams = new HashMap<>();
    if (page != null)
    queryParams.put("page", page);
if (pageSize != null)
    queryParams.put("page_size", pageSize);
if (include != null)
    queryParams.put("include", include);
    
        
    String requestPath = String.format("%s/keyword_set/", baseUrl);
      
    ResultType<InlineResponse2003> resultType = new ResultType<InlineResponse2003>() {};
    return client.doGETRequest(requestPath, resultType, queryParams, formParams);
  }
  /**
   * Return information about single keyword_set
   * 
   * @param id Same as id in keyword_set schema (required)
   */
  public ApiResponse<KeywordSet> keywordSetRetrieve(String id) {
    Map<String, Object> queryParams = new HashMap<>();
    Map<String, Object> formParams = new HashMap<>();
        
        
    String requestPath = String.format("%s/keyword_set/{id}"
      .replaceAll("\\{" + "id" + "\\}", id), baseUrl);
      
    ResultType<KeywordSet> resultType = new ResultType<KeywordSet>() {};
    return client.doGETRequest(requestPath, resultType, queryParams, formParams);
  }
  /**
   * Returns list of places used for describing events
   * place endpoint returns places connected with events. What this means is that all filtering is applied to events. Response then contains those places that host the events that have passed filters. Exceptions to this are marked.
   * @param page request particular page in paginated results (optional)
   * @param pageSize request that server delivers page_size results in response (optional)
   * @param showAllPlaces Show all places, including those that are not hosting any events. Otherwise such places are hidden. When show_all_places is specified, no other filter is applied. (optional)
   * @param text Search (case insensitive) through all multilingual text fields (name, description, short_description, info_url) of an event (every language). Multilingual fields contain the text that users are expected to care about, thus multilinguality is useful discriminator. (optional)
   * @param lastModifiedSince Search for events that have been modified since or at this time. (optional)
   * @param start Search for events beginning or ending after this time. Dates can be specified using ISO 8601 (\&quot;2016-01-12\&quot;) and additionally \&quot;today\&quot;. (optional)
   * @param end Search for events beginning or ending before this time. Dates can be specified using ISO 8601 (\&quot;2016-01-12\&quot;) and additionally \&quot;today\&quot;. (optional)
   * @param bbox Search for events that are within this bounding box. Decimal coordinates are given in order west, south, east, north. Period is used as decimal separator. (optional)
   * @param dataSource Search for events that come from the specified source (optional)
   * @param location Search for events in given locations as specified by id. Multiple ids are separated by comma (optional)
   * @param keyword Search for events with given keywords as specified by id. Multiple ids are separated by comma (optional)
   * @param recurring Search for events based on whether they are part of recurring event set. &#39;super&#39; specifies recurring, while &#39;sub&#39; is non-recurring. (optional)
   * @param minDuration Search for events that are longer than given time in seconds (optional)
   * @param maxDuration Search for events that are shorter than given time in seconds (optional)
   * @param organization Search for events that have given organization as source (optional)
   */
  public ApiResponse<InlineResponse2004> placeList(Integer page, Integer pageSize, Boolean showAllPlaces, String text, String lastModifiedSince, OffsetDateTime start, OffsetDateTime end, List<String> bbox, String dataSource, List<Integer> location, String keyword, String recurring, Integer minDuration, Integer maxDuration, String organization) {
    Map<String, Object> queryParams = new HashMap<>();
    Map<String, Object> formParams = new HashMap<>();
    if (page != null)
    queryParams.put("page", page);
if (pageSize != null)
    queryParams.put("page_size", pageSize);
if (showAllPlaces != null)
    queryParams.put("show_all_places", showAllPlaces);
if (text != null)
    queryParams.put("text", text);
if (lastModifiedSince != null)
    queryParams.put("last_modified_since", lastModifiedSince);
if (start != null)
    queryParams.put("start", start);
if (end != null)
    queryParams.put("end", end);
if (bbox != null)
    queryParams.put("bbox", bbox);
if (dataSource != null)
    queryParams.put("data_source", dataSource);
if (location != null)
    queryParams.put("location", location);
if (keyword != null)
    queryParams.put("keyword", keyword);
if (recurring != null)
    queryParams.put("recurring", recurring);
if (minDuration != null)
    queryParams.put("min_duration", minDuration);
if (maxDuration != null)
    queryParams.put("max_duration", maxDuration);
if (organization != null)
    queryParams.put("organization", organization);
    
        
    String requestPath = String.format("%s/place/", baseUrl);
      
    ResultType<InlineResponse2004> resultType = new ResultType<InlineResponse2004>() {};
    return client.doGETRequest(requestPath, resultType, queryParams, formParams);
  }
  /**
   * Return information for single place
   * 
   * @param id Id as defined in place model (required)
   */
  public ApiResponse<Place> placeRetrieve(String id) {
    Map<String, Object> queryParams = new HashMap<>();
    Map<String, Object> formParams = new HashMap<>();
        
        
    String requestPath = String.format("%s/place/{id}/"
      .replaceAll("\\{" + "id" + "\\}", id), baseUrl);
      
    ResultType<Place> resultType = new ResultType<Place>() {};
    return client.doGETRequest(requestPath, resultType, queryParams, formParams);
  }
  
}
